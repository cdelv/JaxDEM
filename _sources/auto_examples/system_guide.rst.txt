
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/system_guide.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_system_guide.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_system_guide.py:


The Simulation System
----------------------------------------

Now that we know how to use and manipulate the simulation state
(:py:class:`~jaxdem.state.State`), it's time to delve into the simulation
configuration in :py:class:`~jaxdem.system.System`.

A :py:class:`~jaxdem.system.System` holds the "static" configuration of a
simulation, such as the domain, integrator settings, and force model. Although
we call it "static", many fields (e.g., the time step :math:`\Delta t`,
domain dimensions, boundary conditions) can be changed at runtime—even inside a
JIT-compiled function—because both :py:class:`~jaxdem.state.State` and
:py:class:`~jaxdem.system.System` are JAX pytrees.

.. GENERATED FROM PYTHON SOURCE LINES 18-22

System Creation
~~~~~~~~~~~~~~~~~~~~~
By default, :py:meth:`~jaxdem.system.System.create` initializes unspecified
attributes (e.g., domain, force_model, :math:`\Delta t`) with sensible defaults.

.. GENERATED FROM PYTHON SOURCE LINES 22-28

.. code-block:: Python


    import dataclasses as _dc
    import jax
    import jax.numpy as jnp
    import jaxdem as jdem








.. GENERATED FROM PYTHON SOURCE LINES 29-33

It is essential that the system's shape matches the state's shape.
Some components, like those in :py:mod:`~jaxdem.domains` require matching dimensions because
they transform the state's arrays of shape \( (N, d) \) where \( d \) must
agree with the system.

.. GENERATED FROM PYTHON SOURCE LINES 33-38

.. code-block:: Python


    state = jdem.State.create(pos=jnp.zeros((1, 2)))
    system = jdem.System.create(state.shape)
    state, system = system.step(state, system)  # one step








.. GENERATED FROM PYTHON SOURCE LINES 39-47

A note on static methods
~~~~~~~~~~~~~~~~~~~~~~~~
Every operation on :py:class:`~jaxdem.state.State` and
:py:class:`~jaxdem.system.System` (``step``, ``trajectory_rollout``,
``merge``, ``stack``, etc.) is a **static method**. That means
``system.step(state, system)`` and ``jdem.System.step(state, system)`` are
equivalent. Static methods make it straightforward to use these operations
inside :py:func:`jax.jit`, :py:func:`jax.vmap`, and other JAX transforms.

.. GENERATED FROM PYTHON SOURCE LINES 49-52

Configuring the System
~~~~~~~~~~~~~~~~~~~~~~~~
You can configure submodules when creating the system via keyword arguments.

.. GENERATED FROM PYTHON SOURCE LINES 52-56

.. code-block:: Python


    system = jdem.System.create(state.shape, domain_type="periodic")
    print("periodic domain:", system.domain)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    periodic domain: PeriodicDomain(box_size=Array([1., 1.], dtype=float32), anchor=Array([0., 0.], dtype=float32))




.. GENERATED FROM PYTHON SOURCE LINES 57-58

You can also pass constructor arguments to submodules via *_kw dictionaries.

.. GENERATED FROM PYTHON SOURCE LINES 58-66

.. code-block:: Python


    system = jdem.System.create(
        state.shape,
        domain_type="periodic",
        domain_kw=dict(box_size=10.0 * jnp.ones(2), anchor=jnp.zeros(2)),
    )
    print("periodic domain (10x10):", system.domain)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    periodic domain (10x10): PeriodicDomain(box_size=Array([10., 10.], dtype=float32), anchor=Array([0., 0.], dtype=float32))




.. GENERATED FROM PYTHON SOURCE LINES 67-72

Manually swapping a submodule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Internally, :py:meth:`~jaxdem.system.System.create` builds each submodule and
performs sanity checks. You can also create a submodule manually and replace
it using:

.. GENERATED FROM PYTHON SOURCE LINES 72-77

.. code-block:: Python


    domain = jdem.Domain.create("free", dim=2)
    system.domain = domain
    print("free default domain:", system.domain)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    free default domain: FreeDomain(box_size=Array([1., 1.], dtype=float32), anchor=Array([0., 0.], dtype=float32))




.. GENERATED FROM PYTHON SOURCE LINES 78-83

Time stepping
~~~~~~~~~~~~~
The system controls how to advance the simulation in time.
You can perform a single step or multiple steps in a batch. When taking many
steps, batched stepping uses :py:func:`jax.lax.scan` under the hood for speed.

.. GENERATED FROM PYTHON SOURCE LINES 83-90

.. code-block:: Python


    state = jdem.State.create(jnp.zeros((1, 2)))
    state, system = system.step(state, system)  # 1 step

    # Multiple steps in a single call:
    state, system = system.step(state, system, n=10)  # 10 steps








.. GENERATED FROM PYTHON SOURCE LINES 91-97

Trajectory rollout
~~~~~~~~~~~~~~~~~~~~~
If you want to store snapshots along the way, use
:py:meth:`~jaxdem.system.System.trajectory_rollout`. This records `n` snapshots,
taking `stride` internal steps between snapshots, i.e., a total of
:math:`n \cdot \text{stride}` integration steps.

.. GENERATED FROM PYTHON SOURCE LINES 97-104

.. code-block:: Python


    state = jdem.State.create(jnp.zeros((1, 2)))

    state, system, trajectory = system.trajectory_rollout(
        state, system, n=10, stride=2  # total steps = 20
    )








.. GENERATED FROM PYTHON SOURCE LINES 105-107

The trajectory is a Tuple[State, System] with an extra leading snapshot axis
of length `n`.

.. GENERATED FROM PYTHON SOURCE LINES 107-111

.. code-block:: Python


    traj_state, traj_system = trajectory
    print("trajectory pos shape:", traj_state.pos.shape)  # (n, N, d)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    trajectory pos shape: (10, 1, 2)




.. GENERATED FROM PYTHON SOURCE LINES 112-116

Batched simulations with vmap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You can run many independent simulations in parallel with :py:func:`jax.vmap`.
Make sure the initialization returns per-simulation State/System pairs.

.. GENERATED FROM PYTHON SOURCE LINES 116-132

.. code-block:: Python



    def initialize(i):
        st = jdem.State.create(jnp.zeros((1, 2)))
        sys = jdem.System.create(
            st.shape,
            domain_type="reflect",
            domain_kw=dict(box_size=(2 + i) * jnp.ones(2), anchor=jnp.zeros(2)),
        )
        return st, sys


    # Create a batch of 5 simulations
    state_b, system_b = jax.vmap(initialize)(jnp.arange(5))
    print(system_b.domain)  # batched variable domain





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ReflectDomain(box_size=Array([[2., 2.],
           [3., 3.],
           [4., 4.],
           [5., 5.],
           [6., 6.]], dtype=float32), anchor=Array([[0., 0.],
           [0., 0.],
           [0., 0.],
           [0., 0.],
           [0., 0.]], dtype=float32), restitution_coefficient=Array([1., 1., 1., 1., 1.], dtype=float32))




.. GENERATED FROM PYTHON SOURCE LINES 133-135

Advance each simulation by 10 steps.
Use the class method (or a small wrapper) to avoid variable shadowing.

.. GENERATED FROM PYTHON SOURCE LINES 135-141

.. code-block:: Python


    state_b, system_b = jax.vmap(lambda st, sys: jdem.System.step(st, sys, n=10))(
        state_b, system_b
    )
    print("batched pos shape:", state_b.pos.shape)  # (batch, N, d)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    batched pos shape: (5, 1, 2)




.. GENERATED FROM PYTHON SOURCE LINES 142-143

Another way to create batch systems is the stack method:

.. GENERATED FROM PYTHON SOURCE LINES 143-151

.. code-block:: Python


    state = jdem.State.create(jnp.zeros((1, 2)))
    system = jdem.System.create(
        state.shape,
    )

    system = system.stack([system, system, system])
    print("stacked system:", system)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    stacked system: System(linear_integrator=VelocityVerlet(), rotation_integrator=VelocityVerletSpiral(), collider=NaiveSimulator(), domain=FreeDomain(box_size=Array([[1., 1.],
           [1., 1.],
           [1., 1.]], dtype=float32), anchor=Array([[0., 0.],
           [0., 0.],
           [0., 0.]], dtype=float32)), force_manager=ForceManager(gravity=Array([[0., 0.],
           [0., 0.],
           [0., 0.]], dtype=float32), external_force=Array([[[0., 0.]],

           [[0., 0.]],

           [[0., 0.]]], dtype=float32), external_force_com=Array([[[0., 0.]],

           [[0., 0.]],

           [[0., 0.]]], dtype=float32), external_torque=Array([[[0.]],

           [[0.]],

           [[0.]]], dtype=float32), is_com_force=(), force_functions=(), energy_functions=()), bonded_force_model=None, force_model=SpringForce(laws=()), mat_table=MaterialTable(props={'density': Array([[0.27],
           [0.27],
           [0.27]], dtype=float32), 'poisson': Array([[0.3],
           [0.3],
           [0.3]], dtype=float32), 'young': Array([[10000.],
           [10000.],
           [10000.]], dtype=float32)}, pair={'density_eff': Array([[[0.27]],

           [[0.27]],

           [[0.27]]], dtype=float32), 'poisson_eff': Array([[[0.3]],

           [[0.3]],

           [[0.3]]], dtype=float32), 'young_eff': Array([[[10000.]],

           [[10000.]],

           [[10000.]]], dtype=float32)}, matcher=HarmonicMaterialMatchmaker()), dt=Array([0.005, 0.005, 0.005], dtype=float32), time=Array([0., 0., 0.], dtype=float32), dim=Array([2, 2, 2], dtype=int32), step_count=Array([0, 0, 0], dtype=int32), key=Array([[0, 0],
           [0, 0],
           [0, 0]], dtype=uint32), interact_same_bond_id=Array([False, False, False], dtype=bool))





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.849 seconds)


.. _sphx_glr_download_auto_examples_system_guide.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: system_guide.ipynb <system_guide.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: system_guide.py <system_guide.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: system_guide.zip <system_guide.zip>`
