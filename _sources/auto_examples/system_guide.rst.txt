
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/system_guide.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_system_guide.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_system_guide.py:


The Simulation System
----------------------------------------

Now that we know how to use and manipulate the simulation state
(:py:class:`~jaxdem.state.State`), it's time to delve into the simulation
configuration in :py:class:`~jaxdem.system.System`.

A :py:class:`~jaxdem.system.System` holds the "static" configuration of a
simulation, such as the domain, integrator settings, and force model. Although
we call it "static", many fields (e.g., the time step :math:`\Delta t`,
domain dimensions, boundary conditions) can be changed at runtime—even inside a
JIT-compiled function—because both :py:class:`~jaxdem.state.State` and
:py:class:`~jaxdem.system.System` are JAX pytrees.

.. GENERATED FROM PYTHON SOURCE LINES 18-22

System Creation
~~~~~~~~~~~~~~~~~~~~~
By default, :py:meth:`~jaxdem.system.System.create` initializes unspecified
attributes (e.g., domain, force_model, :math:`\Delta t`) with sensible defaults.

.. GENERATED FROM PYTHON SOURCE LINES 22-28

.. code-block:: Python


    import dataclasses as _dc
    import jax
    import jax.numpy as jnp
    import jaxdem as jdem








.. GENERATED FROM PYTHON SOURCE LINES 29-33

It is essential that the system's shape matches the state's shape.
Some components, like those in :py:mod:`~jaxdem.domains` require matching dimensions because
they transform the state's arrays of shape \( (N, d) \) where \( d \) must
agree with the system.

.. GENERATED FROM PYTHON SOURCE LINES 33-38

.. code-block:: Python


    state = jdem.State.create(pos=jnp.zeros((1, 2)))
    system = jdem.System.create(state.shape)
    state, system = system.step(state, system)  # one step








.. GENERATED FROM PYTHON SOURCE LINES 39-42

Configuring the System
~~~~~~~~~~~~~~~~~~~~~~~~
You can configure submodules when creating the system via keyword arguments.

.. GENERATED FROM PYTHON SOURCE LINES 42-46

.. code-block:: Python


    system = jdem.System.create(state.shape, domain_type="periodic")
    print("periodic domain:", system.domain)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    periodic domain: PeriodicDomain(box_size=Array([1., 1.], dtype=float32), anchor=Array([0., 0.], dtype=float32))




.. GENERATED FROM PYTHON SOURCE LINES 47-48

You can also pass constructor arguments to submodules via *_kw dictionaries.

.. GENERATED FROM PYTHON SOURCE LINES 48-56

.. code-block:: Python


    system = jdem.System.create(
        state.shape,
        domain_type="periodic",
        domain_kw=dict(box_size=10.0 * jnp.ones(2), anchor=jnp.zeros(2)),
    )
    print("periodic domain (10x10):", system.domain)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    periodic domain (10x10): PeriodicDomain(box_size=Array([10., 10.], dtype=float32), anchor=Array([0., 0.], dtype=float32))




.. GENERATED FROM PYTHON SOURCE LINES 57-62

Manually swapping a submodule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Internally, :py:meth:`~jaxdem.system.System.create` builds each submodule and
performs sanity checks. You can also create a submodule manually and replace
it using:

.. GENERATED FROM PYTHON SOURCE LINES 62-67

.. code-block:: Python


    domain = jdem.Domain.create("free", dim=2)
    system.domain = domain
    print("free default domain:", system.domain)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    free default domain: FreeDomain(box_size=Array([1., 1.], dtype=float32), anchor=Array([0., 0.], dtype=float32))




.. GENERATED FROM PYTHON SOURCE LINES 68-73

Time stepping
~~~~~~~~~~~~~
The system controls how to advance the simulation in time.
You can perform a single step or multiple steps in a batch. When taking many
steps, batched stepping uses :py:func:`jax.lax.scan` under the hood for speed.

.. GENERATED FROM PYTHON SOURCE LINES 73-80

.. code-block:: Python


    state = jdem.State.create(jnp.zeros((1, 2)))
    state, system = system.step(state, system)  # 1 step

    # Multiple steps in a single call:
    state, system = system.step(state, system, n=10)  # 10 steps








.. GENERATED FROM PYTHON SOURCE LINES 81-87

Trajectory rollout
~~~~~~~~~~~~~~~~~~~~~
If you want to store snapshots along the way, use
:py:meth:`~jaxdem.system.System.trajectory_rollout`. This records `n` snapshots,
taking `stride` internal steps between snapshots, i.e., a total of
:math:`n \cdot \text{stride}` integration steps.

.. GENERATED FROM PYTHON SOURCE LINES 87-94

.. code-block:: Python


    state = jdem.State.create(jnp.zeros((1, 2)))

    state, system, trajectory = system.trajectory_rollout(
        state, system, n=10, stride=2  # total steps = 20
    )








.. GENERATED FROM PYTHON SOURCE LINES 95-97

The trajectory is a Tuple[State, System] with an extra leading snapshot axis
of length `n`.

.. GENERATED FROM PYTHON SOURCE LINES 97-101

.. code-block:: Python


    traj_state, traj_system = trajectory
    print("trajectory pos shape:", traj_state.pos.shape)  # (n, N, d)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    trajectory pos shape: (10, 1, 2)




.. GENERATED FROM PYTHON SOURCE LINES 102-106

Batched simulations with vmap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You can run many independent simulations in parallel with :py:func:`jax.vmap`.
Make sure the initialization returns per-simulation State/System pairs.

.. GENERATED FROM PYTHON SOURCE LINES 106-122

.. code-block:: Python



    def initialize(i):
        st = jdem.State.create(jnp.zeros((1, 2)))
        sys = jdem.System.create(
            state.shape,
            domain_type="reflect",
            domain_kw=dict(box_size=(2 + i) * jnp.ones(2), anchor=jnp.zeros(2)),
        )
        return st, sys


    # Create a batch of 5 simulations
    state_b, system_b = jax.vmap(initialize)(jnp.arange(5))
    print(system_b.domain)  # batched variable domain





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ReflectDomain(box_size=Array([[2., 2.],
           [3., 3.],
           [4., 4.],
           [5., 5.],
           [6., 6.]], dtype=float32), anchor=Array([[0., 0.],
           [0., 0.],
           [0., 0.],
           [0., 0.],
           [0., 0.]], dtype=float32))




.. GENERATED FROM PYTHON SOURCE LINES 123-125

Advance each simulation by 10 steps.
Use the class method (or a small wrapper) to avoid variable shadowing.

.. GENERATED FROM PYTHON SOURCE LINES 125-130

.. code-block:: Python


    state_b, system_b = jax.vmap(lambda st, sys: jdem.System.step(st, sys, n=10))(
        state_b, system_b
    )
    print("batched pos shape:", state_b.pos.shape)  # (batch, N, d)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    batched pos shape: (5, 1, 2)





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.921 seconds)


.. _sphx_glr_download_auto_examples_system_guide.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: system_guide.ipynb <system_guide.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: system_guide.py <system_guide.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: system_guide.zip <system_guide.zip>`
